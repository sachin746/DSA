
# ðŸ§  Algorithm Patterns Cheat Sheet

## 1. Is the array sorted?
- Use **Binary Search**
- Use **Two Pointers**
- Use **Greedy**
- Use **Prefix Sums**

---

## 2. Need optimization? (max/min/sum/subarray)
- **Sliding Window**
- **Dynamic Programming**
- **Greedy Algorithms**
- **Kadaneâ€™s Algorithm**

---

## 3. Looking for duplicates, counts, frequencies?
- **HashMap**
- **HashSet**
- **Frequency Array**
- **Bitmask** (if constraints allow)

---

## 4. Need substrings or fixed-size subarrays?
- **Sliding Window**
- **Two Pointers**

---

## 5. Need frequent min/max in a window?
- **Monotonic Queue**
- **Deque**
- **Heap**

---

## 6. Generate subsets, permutations, combinations?
- **Backtracking (DFS)**

---

## 7. Matching, parsing, balanced symbols?
- **Stack**
  - Balanced Parentheses
  - Expression Parsing
  - HTML/XML Tag Matching

---

## 8. Graph problems? (paths, cycles, connectivity)
- **BFS**
- **DFS**
- **Topological Sort**
- **Union-Find**
- **Dijkstra** (shortest path)
- **Bellmanâ€“Ford**
- **Floydâ€“Warshall**

---

## 9. Tree problems?
- **DFS / BFS**
- **Recursion**
- **Binary Heap**
- **Segment Tree**
- **Tree DP**

---

## 10. Range queries (sum/min/max)?
- **Prefix Sum**
- **Segment Tree**
- **Fenwick Tree (BIT)**

---

## 11. Dynamic Programming patterns
- Identify **states**
- Identify **transitions**
- Identify **base cases**
- Common types:
  - 1D DP
  - 2D DP
  - Knapsack DP
  - LIS / LCS
  - DP on Trees
  - Bitmask DP

---

## 12. When stuck:
- Try converting the problem to a known pattern
- Draw examples
- Think brute force â†’ optimize
- Check constraints (n â‰¤ 1e5? O(n log n) max)


